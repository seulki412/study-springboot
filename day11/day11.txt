1. 양방향 매핑
	- 현재 객체는 Member가 Team을 가졌으나, Team은 Member를 가지지 못한다.
	- 객체 참조와 외래키의 가장 큰 차이점
	- 테이블은 FK만 있으면 양쪽에 연관관계를 알 수 있다.
	- Member -> Team : N -> 1	=>@ManyToOne
	- Team -> Member : 1 -> N	=>@OneToMany

2. 테이블 연관관계
	- 관계 1개가 되어있으면
	- Member 테이블 입장에서 Team 테이블 조인 가능
	- Team 테이블 입장에서 Member 테이블 조인 가능

3. 객체 연관관계
	- 관계 2개
	- Member 객체에서 Team 객체로 연관관계 1개(단방향)
	- Team 객체에서 Member 객체로 연관관계 1개 (단방향)
	- 사실은 단방향 연관관계가 2개 있는 것이다.

4. 관리의 딜레마
	- 둘 중 하나로 외래키를 관리해야 한다.
	- Member에서 Team으로 가는 team의 참조값과, Team에서 Member로 가는 members 참조값이 있다.
		Member에서 Team값이 수정되었을 때, Member table의 TEAM_ID가 수정되야 하는지,
		Team에 있는 members를 수정했을 때, Member table의 TEAM_ID가 수정되야 하는지?

	- DB 입장에서는 Member table에 있는 TEAM_ID만 update되면 된다. -> 룰(주인)이 생긴다.

5. 연관관계의 주인(Owner) - 양방향 매핑 규칙
	- 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
	- 연관관계의 주인만이 외래 키를 관리(등록, 수정)
	- 주인이 아닌쪽은 읽기만 가능
	- 주인은 mappedBy 속성을 사용X
		-> mappedBy : 내가 누군가에 의해서 mapping되었다 라는 뜻
	- 주인이 아니면 mappedBy 속성으로 주인 지정

6. 양뱡향 연관관계 주의
	- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정하자
	- 연관관계 편의 메소드를 생성하자
	- 양방향 매핑시에 무한 루프를 조심하자
		-> toString(), lombok lib 조심할 것

7. 양방향 매핑 정리
	- 단방향 매핑만으로도 이미 연관관계 매핑은 완료
	- 양방향 매핑은 반대 방향으로 조회기능이 추가 된 것 뿐
	- 양방향 사용 이유 : JPQL에서 역방향으로 탐색할 일이 많음
	- 단방향 매핑을 잘 하고, 양방향은 필요할 때 추가해도 됨(테이블에 영향을 주지 않음)
	- 결론 : 객체입장에서 양방향 매핑은 필수는 아님, 필요 시에 그때 생성해도 늦지 않다.
	

8. 연관관계의 주인을 정하는 기준
	- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
	- 연관관계의 주인은 외래 키의 위치를 기준으로 정해야함.










